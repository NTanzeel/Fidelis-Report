\subsection{Reputation Scoring}
It seems clear that collaboration events are a popular method of assessing reputation in online systems. The Sporas and Histos algorithms demonstrate mechanisms for this scoring using collaboration events \cite{mcnally2013} \cite{zacharia2000}. Ultimately, however, these algorithms did not meet the requirements for reputation scoring in this case. The Fidelis system would in theory serve a very large, complex network of users, which constrains the choice of reputation scoring algorithms. The proposed algorithm would need to run on the entire network each day (to score the reputation of both users and posts). Histos and Sporas would both be costly to run given the data stored in our database, therefore a similar, less complex method that adopts elements from Histos and Sporas was considered. This method involves simply performing a sum of each collaboration event, where each event type has a different weighting denoting the relative `importance' of the event in calculating reputation. The weighting functions are shown here for users and posts respectively

\begin{equation}
	\label{eq:rep_weight_user}
		w(c_u) = \left\{\begin{matrix}
			0.3 & if\ c\ is\ an\ upvote\ on\ a\ post\ by\ u\\ 
			-0.3 & if\ c\ is\ a\ downvote\ on\ a\ post\ by\ u \\ 
			0.1 & if\ c\ is\ an\ upvote\ on\ a\ comment\ by\ u \\ 
			-0.1 & if\ c\ is\ a\ downvote\ on\ a\ comment\ by\ u \\ 
			0.2 & if\ c\ is\ a\ comment\ on\ a\ post\ by\ u\\ 
			0.5 & if\ c\ is\ another\ user\ following\ u
		\end{matrix}\right.
\end{equation}
		
\begin{equation}
	\label{eq:rep_weight_post}
	 w(c_p) = \left\{\begin{matrix}
			0.1 & if\ c\ is\ an\ upvote\ on\ post\ p \\ 
			-0.1 & if\ c\ is\ a\ downvote\ on\ post\ p \\ 
			0.2 & if\ c\ is\ a\ comment\ on\ post\ p
	\end{matrix}\right.
\end{equation}

\noindent
where the weighting function \(w\) gives the weighting of a given collaboration event \(c\). The values of this function could, of course, be changed at any time in an attempt to produce more accurate reputation scoring. Once a reputation score has been calculated for each user, these scores will be normalised between 0 and 1. The pseudocode for this process is shown in algorithms \ref{alg:user-reputation} \ref{alg:post-reputation} for reputation scoring users and posts respectively.

\newcommand{\myindent}[1]{
\newline\makebox[#1cm]{}
}

\begin{algorithm}[H]
\caption{User reputation scoring algorithm}
\label{alg:user-reputation}
\begin{algorithmic}[1]
\State $users\gets getAllUsers()$
\ForAll{users $u$}
	\State $post\_upvotes\gets w(post\_upvote)\cdot getPostUpvotes(u)$
	\State $post\_downvotes\gets w(post\_downvote)\cdot getPostDownvotes(u)$
	\State $comment\_upvotes\gets w(comment\_upvote)\cdot getCommentUpvotes(u)$
	\State $comment\_downvotes\gets w(comment\_downvote)\cdot getCommentDownvotes(u)$
	\State $comments\gets w(comment)\cdot commentsgetPostComments(u)$
	\State $followers\gets w(follower)\cdot getFollowers(u)$
	\State $reputation\gets post\_upvotes + post\_downvotes + comment\_upvotes + comment\_downvotes \myindent{2.6} + followers$
\EndFor
\State $users\gets scaleReputation(users)$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Post reputation scoring algorithm}
\label{alg:post-reputation}
\begin{algorithmic}[1]
\State $posts\gets getAllPosts()$
\ForAll{posts $p$}
	\State $upvotes\gets w(upvotes)\cdot getPostUpvotes(p)$
	\State $downvotes\gets w(downvotes)\cdot getPostDownvotes(p)$
	\State $comments\gets w(comments)\cdot getPostComments(p)$
	\State $reputation\gets upvotes + downvotes + comments$
\EndFor
\State $posts\gets scaleReputation(posts)$
\end{algorithmic}
\end{algorithm}


